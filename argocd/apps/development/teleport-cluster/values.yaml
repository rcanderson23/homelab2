##################################################
# Values that must always be provided by the user.
##################################################

# `clusterName` controls the name used to refer to the Teleport cluster, along with
# the externally-facing public address to use to access it. In most setups this must
# be a fully-qualified domain name (e.g. `teleport.example.com`) as this value is
# used as the cluster's public address by default.
#
# Note: When using a fully qualified domain name as your `clusterName`, you will also
# need to configure the DNS provider for this domain to point to the external
# load balancer address of your Teleport cluster.
#
# Warning: The clusterName cannot be changed during a Teleport cluster's lifespan.
# If you need to change it, you must redeploy a completely new cluster.
clusterName: "teleport.carsonanderson.net"

# Name for this kubernetes cluster to be used by teleport users.
kubeClusterName: "homelab"

auth:
  extraVolumeMounts:
    - mountPath: /pg-client
      name: pg-client
      readOnly: true
    - mountPath: /pg-server
      name: pg-server
      readOnly: true
  extraVolumes:
    - name: pg-client
      secret:
        secretName: pg-client
    - name: pg-server
      secret:
        secretName: pg-server-ca
  teleportConfig:
    teleport:
      diag_addr: "0.0.0.0:3000"
      log:
        output: stdout
        severity: INFO
        format:
          output: json
          extra_fields: [level, timestamp, component, caller]
      storage:
        type: postgres
        conn_string: "postgres://teleport@postgres-rw.pg-cluster.svc:5432/teleport?sslmode=verify-full&sslcert=/pg-client/tls.crt&sslkey=/pg-client/tls.key&sslrootcert=/pg-server/ca.crt"
        audit_events_uri:
        - "postgres://teleport@postgres-rw.pg-cluster.svc:5432/teleport_events?sslmode=verify-full&sslcert=/pg-client/tls.crt&sslkey=/pg-client/tls.key&sslrootcert=/pg-server/ca.crt"
        audit_sessions_uri: "s3://dev-teleport-sessions-carson.s3.amazonaws.com"

    proxy_service:
      enabled: false
    auth_service:
      enabled: true
      authentication:
        type: local
      listen_addr: 0.0.0.0:3025
      license_file: /var/lib/license/license.pem
      proxy_listener_mode: multiplex
      tunnel_strategy:
        type: proxy_peering
        agent_connection_count: 1
      access_monitoring: 
        enabled: no
proxy:
  teleportConfig:
    teleport:
      diag_addr: "0.0.0.0:3000"
      log:
        output: stdout
        severity: INFO
        format:
          output: json
          extra_fields: [level, timestamp, component, caller]
    auth_service:
      enabled: false
    proxy_service:
      enabled: true
      web_listen_addr: 0.0.0.0:3080
      public_addr: teleport.carsonanderson.net:443
      https_keypairs:
      - key_file: /etc/teleport-tls/tls.key
        cert_file: /etc/teleport-tls/tls.crt
      https_keypairs_reload_interval: 1h
      auth_servers:
        - teleport-cluster-auth:3025


authentication:
  # Default authentication type. Possible values are 'local' and 'github' for OSS, plus 'oidc' and 'saml' for Enterprise.
  type: local
  secondFactors: ["otp", "webauthn"]

proxyListenerMode: "multiplex"

# Optional setting for configuring session recording.
# See `session_recording` under https://goteleport.com/docs/reference/config/#auth-service
sessionRecording: ""

# Set enterprise to true to use enterprise image
# You will need to download your Enterprise license from the Teleport dashboard and create a secret to use this:
# kubectl -n ${TELEPORT_NAMESPACE?} create secret generic license --from-file=/path/to/downloaded/license.pem
enterprise: true
# Override default Enterprise license name
licenseSecretName: "teleport-license"
# CRDs are installed by default when the operator is enabled. This manual override allows to disable CRD installation
# when deploying multiple releases in the same cluster.
# installCRDs:

# Configuration of the optional Teleport operator
operator:
  # Set enabled to true to add the Kubernetes Teleport Operator
  enabled: false
  # Kubernetes Teleport Operator image
  image: public.ecr.aws/gravitational/teleport-operator
  # Resources to request for the operator container
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: {}
  #  requests:
  #    cpu: "0.5"
  #    memory: "1Gi"
  #  limits:
  #    memory: "1Gi"
  joinMethod: "kubernetes"
  token: "teleport-operator"
  # This is needed to have a sensible name and predictable service account name.
  nameOverride: operator

chartMode: scratch

# validateConfigOnDeploy enables a Kubernetes job before install and upgrade that will verify
# if the teleport.yaml configuration is valid and will block the deployment if it is not
validateConfigOnDeploy: true

# Whether the chart should create a Teleport ProvisionToken for the proxies to join the Teleport cluster.
# Disabling this flag will cause the proxies not to be able to join the auth pods. In this case, the
# Helm chart user is responsible for configuring working join_params on the proxy.
createProxyToken: true

# podMonitor controls the PodMonitor CR (from monitoring.coreos.com/v1)
# This CRD is managed by the prometheus-operator and allows workload to
# get monitored. To use this value, you need to run a `prometheus-operator`
# in the cluster for this value to take effect.
# See https://prometheus-operator.dev/docs/getting-started/introduction/
podMonitor:
  # Whether the chart should deploy a PodMonitor.
  # Disabled by default as it requires the PodMonitor CRD to be installed.
  enabled: true
  # additionalLabels to put on the PodMonitor.
  # This is used to be selected by a specific prometheus instance.
  # Defaults to {prometheus: default} which seems to be the common default prometheus selector
  additionalLabels:
    release: kps
  # interval is the interval between two metrics scrapes. Defaults to 30s
  interval: 30s

persistence:
  enabled: false

highAvailability:
  # Controls the amount of pod replicas. The `highAvailability` comment describes
  # the replication requirements.
  #
  # WARNING: You **must** meet the replication criteria,
  # else the deployment will result in errors and inconsistent data.
  replicaCount: 2
  # Setting 'requireAntiAffinity' to true will use 'requiredDuringSchedulingIgnoredDuringExecution' to require that multiple Teleport pods must not be scheduled on the
  # same physical host. This will result in Teleport pods failing to be scheduled in very small clusters or during node downtime, so should be used with caution.
  # Setting 'requireAntiAffinity' to false (the default) uses 'preferredDuringSchedulingIgnoredDuringExecution' to make this a soft requirement.
  # This setting only has any effect when replicaCount is greater than 1.
  requireAntiAffinity: false
  # If enabled will create a Pod Disruption Budget
  # https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  podDisruptionBudget:
    enabled: false
    minAvailable: 1
  # Settings for cert-manager (can be used for provisioning TLS certs in HA mode)
  # These settings are mutually exclusive with the "tls" value below.
  certManager:
    # If set to true, use cert-manager to get certificates for Teleport to use for TLS termination
    enabled: true
    # If set to true, a common name matching the cluster name will be set in the certificate signing request. This is mandatory for some CAs.
    addCommonName: true
    # If set to true, any additional public addresses configured under the `publicAddr` chart value will be added to the certificate signing request.
    # This setting is not enabled by default to preserve backward compatibility.
    addPublicAddrs: false
    # Name of the Issuer/ClusterIssuer to use for certs
    # NOTE: You will always need to create this yourself when certManager.enabled is true.
    issuerName: "letsencrypt-prod"
    # Kind of Issuer that cert-manager should look for.
    # This defaults to 'Issuer' to keep everything contained within the teleport namespace.
    issuerKind: ClusterIssuer
    # Group of Issuer that cert-manager should look for.
    # This defaults to 'cert-manager.io' which is the default Issuer group.
    issuerGroup: cert-manager.io
  # Injects delay when performing pod rollouts to mitigate the loss of all agent tunnels at the same time
  # See https://github.com/gravitational/teleport/issues/13129
  minReadySeconds: 15

##################################################
# Values that you shouldn't need to change.
##################################################

# Container image for the cluster. By default, the image contains only the
# Teleport application and its runtime dependencies, and does not contain a
# shell.
image: public.ecr.aws/gravitational/teleport-distroless
# Enterprise version of the image. By default, the image contains only the
# Teleport application and its runtime dependencies, and does not contain a
# shell.
enterpriseImage: public.ecr.aws/gravitational/teleport-ent-distroless
# Optional array of imagePullSecrets, to use when pulling from a private registry
imagePullSecrets: []
# Teleport logging configuration
log:
  # Log level for the Teleport process.
  # Available log levels are: DEBUG, INFO, WARNING, ERROR.
  # The default is INFO, which is recommended in production.
  # DEBUG is useful during first-time setup or to see more detailed logs for debugging.
  level: INFO
  # Log output
  # Use a file path to log to disk: e.g. '/var/lib/teleport/teleport.log'
  # Other supported values: 'stdout', 'stderr' and 'syslog'
  output: stderr
  # Log format configuration
  # Possible output values are 'json' and 'text' (default).
  format: json
  # Possible extra_fields values include: timestamp, component, caller, and level.
  # All extra fields are included by default.
  extraFields: ["timestamp", "level", "component", "caller"]

##################################
# Extra Kubernetes configuration #
##################################

# nodeSelector to apply for pod assignment
# https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
nodeSelector: {}

# Turns off the topology spread constraints.
# The feature is automatically turned off on Kubernetes versions below 1.18.
disableTopologySpreadConstraints: false

# Pod topology spread constraints:
# https://kubernetes.io/fr/docs/concepts/workloads/pods/pod-topology-spread-constraints/
# When unset, the chart defaults to a soft topology spread constraint
# that tries to spread pods across hosts and zones.
#
# ```
# topologySpreadConstraints
#   - maxSkew: 1
#     topologyKey: kubernetes.io/hostname
#     whenUnsatisfiable: ScheduleAnyway
#     labelSelector:
#       matchLabels: # dynamically computed
#   - maxSkew: 1
#     topologyKey: topology.kubernetes.io/zone
#     whenUnsatisfiable: ScheduleAnyway
#     labelSelector:
#       matchLabels: # dynamically computed
# ```
topologySpreadConstraints: []

# Affinity for pod assignment
# https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
# NOTE: If affinity is set here, highAvailability.requireAntiAffinity cannot also be used - you can only set one or the other.
affinity: {}

# Kubernetes annotations to apply
# https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
annotations:
  # Annotations for the ConfigMap
  config: {}
  # Annotations for the Deployment
  deployment: {}
  # Annotations for each Pod in the Deployment
  pod: {}
  # Annotations for the Service object
  service: {}
  # Annotations for the ServiceAccount object
  serviceAccount: {}
  # Annotations for the certificate secret generated by cert-manager v1.5+ when
  # highAvailability.certManager.enabled is true
  certSecret: {}
  # Annotations for the Ingress object
  ingress: {}

# extraLabels -- contains additional Kubernetes labels to apply on the resources
# created by the chart.
# See [the Kubernetes label documentation
# ](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)
# for more information.
#
# Note: for PodMonitor labels, see `podMonitor.additionalLabels` instead.
extraLabels:
  # extraLabels.certSecret(object) -- are labels to set on the certificate secret
  # generated by cert-manager v1.5+ when `highAvailability.certManager.enabled`
  # is true.
  certSecret: {}
  # extraLabels.clusterRole(object) -- are labels to set on the ClusterRole.
  clusterRole: {}
  # extraLabels.clusterRoleBinding(object) -- are labels to set on the ClusterRoleBinding.
  clusterRoleBinding: {}
  # extraLabels.role(object) -- are labels to set on the Role.
  config: {}
  # extraLabels.deployment(object) -- are labels to set on the Deployment.
  deployment: {}
  # extraLabels.ingress(object) -- are labels to set on the Ingress.
  ingress: {}
  # extraLabels.job(object) -- are labels to set on the Job run by the Helm hook.
  job: {}
  # extraLabels.jobPod(object) -- are labels to set on the Pods created by the
  # Job run by the Helm hook.
  jobPod: {}
  # extraLabels.persistentVolumeClaim(object) -- are labels to set on the PersistentVolumeClaim.
  persistentVolumeClaim: {}
  # extraLabels.pod(object) -- are labels to set on the Pods created by the
  # Deployment.
  pod: {}
  # extraLabels.podDisruptionBudget(object) -- are labels to set on the podDisruptionBudget.
  podDisruptionBudget: {}
  # extraLabels.secret(object) -- are labels to set on the Secret.
  secret: {}
  # extraLabels.service(object) -- are labels to set on the Service.
  service: {}
  # extraLabels.serviceAccount(object) -- are labels to set on the ServiceAccount.
  serviceAccount: {}

# Kubernetes service account to create/use.
serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # The name of the ServiceAccount to use.
  # If not set and serviceAccount.create is true, the name is generated using the release name.
  # If create is false, the name will be used to reference an existing service account.
  name: ""
  # To set annotations on the service account, use the annotations.serviceAccount value.

# Set to true (default) to create Kubernetes ClusterRole and ClusterRoleBinding.
rbac:
  # Specifies whether a ClusterRole and ClusterRoleBinding should be created.
  # Set to false if your cluster level resources are managed separately.
  create: true

# Options for the Teleport proxy service
# This setting only applies to the proxy service. The teleport auth service is internal-only and always uses a ClusterIP.
# You can override the proxy's backend service to any service type (other than "LoadBalancer") here if really needed.
# To use an Ingress, set service.type=ClusterIP and ingress.enabled=true
service:
  type: LoadBalancer
  # Additional entries here will be added to the service spec.
  spec: {}
    # loadBalancerIP: "1.2.3.4"

# Extra arguments to pass to 'teleport start' for the main Teleport pod
extraArgs: []

# Extra environment to be configured on the Teleport pod
extraEnv: []

# Extra containers to be added to the Teleport pod
extraContainers: []
# - name: nscenter
#   command:
#     - /bin/bash
#     - -c
#     - sleep infinity & wait
#   image: praqma/network-multitool
#   imagePullPolicy: IfNotPresent
#   securityContext:
#     privileged: true
#     runAsNonRoot: false

# Extra volumes to mount into the Teleport pods
# https://kubernetes.io/docs/concepts/storage/volumes/
extraVolumes: []
# - name: myvolume
#   secret:
#     secretName: testSecret

# Extra volume mounts corresponding to the volumes mounted above
extraVolumeMounts: []
# - name: myvolume
#   mountPath: /path/on/host

# Allow the imagePullPolicy to be overridden
imagePullPolicy: IfNotPresent

# A list of initContainers to run before each Teleport pod starts
# https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
initContainers: []
# - name: "teleport-init"
#   image: "alpine"
#   args: ["echo test"]

# If set, will run the command as a postStart handler
# https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/
postStart:
  command: []

# Resources to request for the teleport container
# https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
#
# DANGER: Setting CPU limits is an anti-pattern and harmful in most cases.
# Unless you enabled [the Static CPU management policy](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#static-policy),
# a multithreaded workload with CPU limits will very likely not behave the way
# you expect when approaching its CPU limit.
#
# Teleport will become unstable once throttling starts. We recommend not to set CPU limits.
# See [the GitHub PR](https://github.com/gravitational/teleport/pull/36251) for technical details.
resources: {}
#  requests:
#    cpu: "1"
#    memory: "2Gi"
#  limits:
#    memory: "2Gi"

# goMemLimitRatio configures the GOMEMLIMIT env var set by the chart.
# GOMEMLIMIT instructs the go garbage collector to try to keep allocated memory
# below a given threshold. This is a best-effort attempt, but this helps
# to prevent OOMs in case of bursts.
#
# When the memory limits are set and goMemLimitRatio is non-zero,
# the chart sets the GOMEMLIMIT to `resources.memory.limits * goMemLimitRatio`.
# The value must be between 0 and 1.
# Set to 0 to unset GOMEMLIMIT.
# This has no effect if GOMEMLIMIT is already set through `extraEnv`.
goMemLimitRatio: 0.9

# Pod security context for any pods created by the chart
podSecurityContext: {}
  # fsGroup: 65532

# Security context to add to the container
securityContext: {}
  # runAsUser: 99

# Priority class name to add to the deployment
priorityClassName: ""

# Tolerations for pod assignment
# https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
tolerations: []

# Timeouts for the readiness and liveness probes
# https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
probeTimeoutSeconds: 5

# readinessProbe(object) -- configures the readiness probe settings.
# This can be tuned to keep proxy pods ready even when the auth is unavailable.
#
# The default values mark the pod unready after one minute of failing readiness probe.
readinessProbe:
  # readinessProbe.initialDelaySeconds(int) -- controls the number of seconds after the container has started before
  # liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  initialDelaySeconds: 5
  # readinessProbe.periodSeconds(int) -- controls how often (in seconds) to perform the probe. Minimum value is 1.
  periodSeconds: 5
  # readinessProbe.failureThreshold(int) -- is the minimum consecutive failures for the probe to be considered failed
  # after having succeeded. Minimum value is 1.
  failureThreshold: 12
  # readinessProbe.successThreshold(int) -- is the minimum consecutive successes for the probe to be considered
  # successful after having failed. Minimum value is 1.
  successThreshold: 1

# Kubernetes termination grace period
# https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-handler-execution
#
# This should be greater than 30 seconds as pods are waiting 30 seconds in a preStop hook.
terminationGracePeriodSeconds: 60

